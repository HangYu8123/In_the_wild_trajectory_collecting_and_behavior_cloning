from logging import error
from queue import Empty
import sys
import os
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
import moveit_msgs.srv
from moveit_msgs.srv import GetStateValidityRequest, GetStateValidity
import geometry_msgs.msg
import std_msgs.msg
import kinova_msgs.srv
from math import pi, floor, ceil, fabs

class Arm:
    """ MoveIt! wrapper for planning for the HLP-R robot's arm(s).

    This class provides a simplified interface to the planning capabilities of
    the MoveIt! ROS packages.  To plan to a specific joint configuration::
    
        a = ArmMoveit()
        pose = [pi,pi,pi,pi]
    
        a.goto_pose(pose,is_joint_pos=True)

    """

    def __init__(self, planning_frame='base_link', eef_frame='j2s7s300_ee_link', default_planner="RRTConnectkConfigDefault"):
        """ Create an interface to ROS MoveIt with a given frame and planner.

        Creates an interface to ROS MoveIt!. Right now this only creates
        a planner for a single arm. The default values of the arguments
        should work well for most applications; look into the MoveIt! 
        documentation if you think you'd like to change them.

        **IMPORTANT:** this class maps all commands to the continuous joints
        into (-pi,pi).  For some applications this may result in unexpected
        or undesirable behavior!

        Parameters
        ----------
        planning_frame : str, optional_simplify
            the frame in which MoveIt! should plan
        eef_frame : str, optional
            the end effector frame for pose goals
        default_planner : str, optional
            which planner to use with MoveIt!
        """

        # Make sure the moveit service is up and running
        rospy.logwarn("Waiting for MoveIt! to load")
        try:
            rospy.wait_for_service('compute_ik')
        except rospy.ROSException as e:
            rospy.logerr("No MoveIt service detected. Exiting")
            exit()
        else:
            rospy.loginfo("MoveIt detected: arm planner loading")

        # self.pose = geometry_msgs.msg.PoseStamped()

        # Check if we're using the 7dof
        if 'VECTOR_HAS_KINOVA_7DOF_ARM' in os.environ:
            is_7dof = os.environ['VECTOR_HAS_KINOVA_7DOF_ARM']
        else:
            is_7dof = True

        ## Interface to the robot as a whole.
        self.robot = moveit_commander.RobotCommander()
        
        ## Interface to the world surrounding the robot.
        self.scene = moveit_commander.PlanningSceneInterface()

        ## Array of interfaces to single groups of joints.  
        ## At the moment, only a single arm interface is instantiated
        self.group = moveit_commander.MoveGroupCommander("arm")
        print(self.group.get_end_effector_link())

        ## The name of the planner to use
        self.planner = default_planner

        # Set the planning pose reference frame
        self.group.set_pose_reference_frame(planning_frame)
        self.group.set_end_effector_link(eef_frame)

        ## The names of continuous joints. They will always be remapped
        ## into (-pi,pi)
        if is_7dof:
            self.continuous_joints = ['joint_1','joint_3','joint_5','joint_7']
        else:
            self.continuous_joints = ['shoulder_pan_joint','wrist_1_joint','wrist_2_joint','wrist_3_joint']

    def home_arm(self):
        """
        Homes the arm. 
        """
        rospy.wait_for_service("/j2s7s300_driver/in/home_arm")
        home_service = rospy.ServiceProxy("/j2s7s300_driver/in/home_arm", kinova_msgs.srv.HomeArm)
        home_service()

    def emergency_stop(self):
        """
        Emergency stop the arm
        """
        rospy.wait_for_service("/j2s7s300_driver/in/stop")
        stop_arm = rospy.ServiceProxy("/j2s7s300_driver/in/stop", kinova_msgs.srv.Stop)
        stop_arm()


    def open_gripper(self):
        joint_goal = self.group.get_current_joint_values()
        joint_goal[0] = 1
        self.group.go(joint_goal, wait=True)
        self.group.stop()

    def close_gripper(self):
        joint_goal = self.group.get_current_joint_values()
        joint_goal[0] = 0
        self.group.go(joint_goal, wait=True)
        self.group.stop()

    def start_force_control(self):
        """
        Calls the start force control service.
        """
        rospy.wait_for_service("/j2s7s300_driver/in/start_force_control")
        force_service = rospy.ServiceProxy("/j2s7s300_driver/in/start_force_control", kinova_msgs.srv.Start)
        force_service()
        print("Force control has been enabled")
    
    def stop_force_control(self):
        """
        Calls the stop force control service.
        """
        rospy.wait_for_service("/j2s7s300_driver/in/stop_force_control")
        force_service = rospy.ServiceProxy("/j2s7s300_driver/in/stop_force_control", kinova_msgs.srv.Stop)
        force_service()
    
    def set_velocity(self, velocity=0.2):
        """
        Alters the speed of trajectory

        Parameters
        ----------
        velocity : float
            Allowed values are in (0,1]
        """
        if velocity > 0 and velocity <= 1:
            self.group.set_max_velocity_scaling_factor(velocity)
        else:
            raise Exception("Expected value in the range from 0 to 1 for scaling factor" )

    def set_acceleration(self, acceleration=0.1):
        """
        Alters the acceleration of trajectory

        Parameters
        ----------
        acceleration : float
            Allowed values are in (0,1]
        """
        if acceleration > 0 and acceleration <= 1:
            self.group.set_max_acceleration_scaling_factor(acceleration)
        else:
            raise Exception("Expected value in the range from 0 to 1 for scaling factor" )
        
    def get_IK(self, new_pose = None, root = None, avoid_collisions=False):
        """ Find the corresponding joint angles for an end effector pose
        
        Uses MoveIt! to compute the inverse kinematics for a given end
        effector pose.

        Parameters
        ----------
        new_pose : geometry_msgs/PoseStamped 
            the end effector pose (if none is provided, uses the current pose)
        root : string, optional
            the root link (if none is provided, uses the planning frame)

        Returns
        ----------
        list 
            The joint angles corresponding to the end effector pose
        """
        
        ## from a defined newPose (geometry_msgs.msg.Pose()), retunr its correspondent joint angle(list)
        rospy.wait_for_service('compute_ik')
        compute_ik = rospy.ServiceProxy('compute_ik', moveit_msgs.srv.GetPositionIK)

        pose = (self.get_FK(root=root) if new_pose is None else new_pose)
        try:
            pose = copy.deepcopy(pose)[0]
        except:
            pose = copy.deepcopy(pose)

        msgs_request = moveit_msgs.msg.PositionIKRequest()
        msgs_request.group_name = self.group.get_name()
        msgs_request.pose_stamped.pose = pose
        msgs_request.robot_state.is_diff = True
        msgs_request.timeout.secs = 2
        msgs_request.avoid_collisions = avoid_collisions
        msgs_request.ik_link_names = ["j2s7s300_joint_1", "j2s7s300_joint_2", "j2s7s300_joint_3", "j2s7s300_joint_4",
                        "j2s7s300_joint_5", "j2s7s300_joint_6", "j2s7s300_joint_7"]

        # msgs_request.robot_state = self.robot.get_current_state()
        try:
            jointAngle=compute_ik(msgs_request)
            ans=list(jointAngle.solution.joint_state.position)[2:9]
            ans = self._simplify_joints(ans)
            if jointAngle.error_code.val == -31:
                print('No IK solution')
                return None
            if (jointAngle.error_code.val == -12 or jointAngle.error_code.val==-10) and avoid_collisions is True:
                raise ValueError("Goal or current position is in collision")
            return ans
        except rospy.ServiceException as e:
            print("Service call failed: %s"%e)

        
    def get_FK(self, root = None, state = None):
        """ Find the end effector pose for the current joint configuration
        
        Uses MoveIt! to compute the forward kinematics for a given joint
        configuration.

        Parameters
        ----------
        root : string, optional
            the root link (if none is provided, uses the planning frame)
        state : RobotState, optional
            the state to calculate FK for (if none is provided, uses the 
                current state)
        
        Returns
        ----------
        geometry_msgs/PoseStamped []
            the pose of the end effector
        """
        rospy.wait_for_service('compute_fk')
        compute_fk = rospy.ServiceProxy('compute_fk', moveit_msgs.srv.GetPositionFK)

        header = std_msgs.msg.Header()
        header.frame_id = root
        header.stamp = rospy.Time.now()
        # THE CHANGE:
        fk_link_names = ['j2s7s300_link_7']
        robot_state = self.robot.get_current_state()
        #print(robot_state.joint_state.position) 
        #joints = dict(zip(robot_state.joint_state.name[2:9], robot_state.joint_state.position[2:9]))
        #joints = self._simplify_joints(joints)
        #print(robot_state.joint_state.position[2:9])
        #robot_state.joint_state.position[2:9] = joints.values()
        try:
            reply=compute_fk(header,fk_link_names,robot_state)
            return reply.pose_stamped

        except rospy.ServiceException as e:
            print("Service call failed: %s"%e)

    def check_arm_collision(self, joints = None):
        '''Gets whether a given joint of the arm pose is in collision 
        with an object in the scene or not. If no joints
        are provided, checks if the current pose is in collision.
        
        Parameters
        ----------
        joints : list or dictionary, optional
            If not provided, uses current joint pos.
        Returns
        ----------
        bool
            True if arm is in collision. False otherwise.
        '''
        rospy.wait_for_service('/check_state_validity')
        collison_service = rospy.ServiceProxy('/check_state_validity', GetStateValidity)

        if joints is None:
            joints = self.get_current_pose()

        robot_state = self.state_from_joints(joints)

        validityRequest = GetStateValidityRequest()
        validityRequest.robot_state=robot_state
        
        collisions = collison_service(validityRequest)
        
        for i in range(len(collisions.contacts)):
            body_1 = collisions.contacts[i].contact_body_1
            body_2 = collisions.contacts[i].contact_body_2
            if "j2" in body_1 or "j2" in body_2:
                return True
        
        return False

    def get_arm_collisions(self, joints = None):
        '''Returns a list of collisions with the arm given a joint pose. 
        If no joints are provided, checks if the current pose 
        is in collision.
        
        Parameters
        ----------
        joints : list or dictionary, optional
            If not provided, uses current joint pos.
        Returns
        ----------
        list
            list of tuples containing arm collisions.
        '''
        rospy.wait_for_service('/check_state_validity')
        collison_service = rospy.ServiceProxy('/check_state_validity', GetStateValidity)

        if joints is None:
            joints = self.get_current_pose()

        robot_state = self.state_from_joints(joints)

        validityRequest = GetStateValidityRequest()
        validityRequest.robot_state=robot_state
        
        collisions = collison_service(validityRequest)
        
        collision_list = []
        for i in range(len(collisions.contacts)):
            body_1 = collisions.contacts[i].contact_body_1
            body_2 = collisions.contacts[i].contact_body_2
            if "j2" in body_1 or "j2" in body_2:
                collision_list.append((body_1, body_2))
        
        return collision_list

    def check_robot_collision(self, joints = None):
        '''Gets whether any part of the robot is currently in collision 
        or not. Optionally can provide joints. 
        
        Parameters
        ----------
        joints : list or dictionary, optional
            If not provided, uses current joint pos.
        Returns
        ----------
        bool
            True on success
        '''
        rospy.wait_for_service('/check_state_validity')
        collison_service = rospy.ServiceProxy('/check_state_validity', GetStateValidity)

        if joints is None:
            joints = self.get_current_pose()

        robot_state = self.state_from_joints(joints)

        validityRequest = GetStateValidityRequest()
        validityRequest.robot_state=robot_state
        
        collisions = collison_service(validityRequest)
        
        if len(collisions.contacts) == 0:
            return False
        return True

    def get_robot_collisions(self, joints = None):
        '''Returns a list of collisions with the robot given a joint pose. 
        If no joints are provided, checks if the current pose 
        is in collision.
        
        Parameters
        ----------
        joints : list or dictionary, optional
            If not provided, uses current joint pos.
        Returns
        ----------
        list
            list of tuples containing robot collisions.
        '''
        rospy.wait_for_service('/check_state_validity')
        collison_service = rospy.ServiceProxy('/check_state_validity', GetStateValidity)

        if joints is None:
            joints = self.get_current_pose()

        robot_state = self.state_from_joints(joints)

        validityRequest = GetStateValidityRequest()
        validityRequest.robot_state=robot_state
        
        collisions = collison_service(validityRequest)
        
        collision_list = []
        for i in range(len(collisions.contacts)):
            body_1 = collisions.contacts[i].contact_body_1
            body_2 = collisions.contacts[i].contact_body_2
            collision_list.append((body_1, body_2))
        
        return collision_list

    def plan_joint_pos(self, target, starting_config=None):
        """ Plan a trajectory to reach a given joint configuration
        
        Uses MoveIt! to plan a trajectory to reach a given joint
        configuration

        Parameters
        ----------
        target : list or dict
            if a list, a list of positions for all active joints 
            in the group; if a dictionary, a mapping of joint names 
            to positions for the joints that should be moved (all other 
            joints will be held at their current angles).
        starting_config : RobotState, optional
            the starting configuration to plan from.  If not set, will 
            be set to the current state of the robot.

        Returns
        ----------
        RobotTrajectory
            the plan for reaching the target position
        """
        
        self.set_start_state(starting_config)
        self.set_joint_target(target)
        return self.get_plan()

    def plan_ee_pos(self, target, starting_config=None):
        """ Plan a trajectory to reach a given end effector position
        
        Uses MoveIt! to plan a trajectory to reach a given end effector
        position

        Parameters
        ----------
        target : geometry_msgs/Pose or geometry_msgs/PoseStamped
            the desired pose of the end effector
        starting_config : RobotState, optional
            the starting configuration to plan from.  If not set, will 
            be set to the current state of the robot.

        Returns
        ----------
        RobotTrajectory
            the plan for reaching the target position
        """
        self.set_start_state(starting_config)
        self.set_ee_target(target)
        return self.get_plan()

    def set_start_state(self, joint_config=None):
        """ Set the starting state from which to plan
        
        Sets the MoveIt! starting position in preparation for planning

        Parameters
        ----------
        joint_config (RobotState) -- the starting configuration to plan
            from.  If not set, will be set to the current state of the robot.
        """

        if joint_config is not None:
            start_state = joint_config
        else:
            start_state = self._copy_state()

        try:
            self.group.set_start_state(start_state)
        except moveit_commander.MoveItCommanderException as e:
            rospy.logerr('Unable to set start state: {}'.format(e))


    def set_joint_target(self, target):
        """ Set the joint configuration target
        
        Sets the MoveIt! target position in preparation for planning

        Parameters
        ----------
        target (list or dict) -- if a list, a list of positions for
            all active joints in the group; if a dictionary, a mapping
            of joint names to positions for the joints that should be
            moved (all other joints will be held at their current angles).
        """
        try:
            self.group.set_joint_value_target(self._simplify_joints(target))
            self.group.set_planner_id(self.planner)
        except moveit_commander.MoveItCommanderException as e:
            rospy.logerr('Unable to set target and planner: {}'.format(e))

    def set_ee_target(self, target):
        """ Set the end effector position target
        
        Sets the MoveIt! target position in preparation for planning

        Parameters
        ----------
        target : geometry_msgs/Pose
            the desired pose of the end effector
        """
        
        try:
            # sanitize possible numpy before sending off to moveit
            if type(target).__module__ == 'numpy':
                target = target.tolist()

            self.group.set_pose_target(target)
            self.group.set_planner_id(self.planner)
        except moveit_commander.MoveItCommanderException as e:
            rospy.logerr('Unable to set target and planner: {}'.format(e))

    def get_plan(self):
        '''Generates a plan for reaching the current goal
        
        Uses MoveIt! to generate a plan based on the previously-set starting
        position and target position.

        .. note:: You must set the target and starting position before calling
            this function.
        
        Returns
        ----------
        RobotTrajectory
            the plan for reaching the target position
        '''
        try:
            plan =  self.group.plan()[1]
        except moveit_commander.MoveItCommanderException as e:
            rospy.logerr('No plan found: {}'.format(e))
            return None
        return plan

    def move_robot(self, plan, wait = True):
        '''Moves the robot according to a plan
        
        Uses MoveIt! to move the arm according to the provided plan.

        .. warning:: The plans can be stitched together, but this can 
            have unexpected issues since the plan boundaries can violate 
            acceleration limits.
        
        Parameters
        ----------
        plan : RobotTrajectory
            a plan generated by MoveIt!
        wait : bool, optional
            whether to return immediately or block until movement is complete. 
            Default value is True

        Returns
        ----------
        bool
            True on success
        '''
        return self.group.execute(plan, wait)




    def plan_joint_waypoints(self, targets, starting_config=None):
        '''Generates a multi-segment plan to reach waypoints in joint space
        
        Uses MoveIt! to generate a plan from target to target. One plan is
        generated for each segment.

        .. warning:: The plans can be stitched together, but this can 
            have unexpected issues since the plan boundaries can violate 
            acceleration limits.
        
        Parameters
        ----------
        targets : list
            a list of joint targets (either list or dict; see documentation 
            for :py:meth:`plan_joint_pos` )
        starting_config : RobotState
            the starting state. If not provided this will default to the 
            current state of the robot.

        Returns
        ----------
        list of RobotTrajectory
            the plan for reaching the target position
        '''
        all_plans = []
        current_config = starting_config
        for target in targets:
            plan = self.plan_joint_pos(target, starting_config=current_config)
            if plan!=None:
                all_plans.append(plan)
                try:
                    current_config=self.state_from_trajectory(plan.joint_trajectory)
                except moveit_commander.MoveItCommanderException as e:
                    rospy.logerr("Couldn't set configuration. Error:{}".format(e))
        return all_plans

    def plan_ee_waypoints(self, targets, starting_config=None):
        '''Generates a multi-segment plan to reach end effector waypoints
        
        Uses MoveIt! to generate a plan from target to target. One plan is
        generated for each segment.

        .. warning:: The plans can be stitched together, but this can have 
            unexpected issues since the plan boundaries can violate 
            acceleration limits.
        
        Parameters
        ----------
        targets : list
            a list of geometry_msgs/Pose for the end effector
        starting_config : RobotState
            the starting state. If not provided this will default to the 
            current state of the robot.

        Returns
        ----------
        list of RobotTrajectory
            the plan for reaching the target position
        '''
        all_plans = []
        plan_start_config = starting_config
        for target in targets:
            plan = self.plan_ee_pos(target, plan_start_config)
            if plan is not None:
                if len(plan.joint_trajectory.points) != 0:
                    all_plans.append(plan)
                    plan_start_config = self.state_from_trajectory(
                        plan.joint_trajectory)
            else:
                rospy.logerr('EE waypoints could not calculate plan')
        return all_plans

    def go_to_joint_state(self, target, grip_pos = None, grip = None, wait=True):
        # move to the target joint configuration
        
        success = self.group.go(target, wait=wait)
        if grip_pos is not None:
            if grip_pos > 0.8:
                grip.close()
            else:
                grip.open()
        return success

    def go_to_joint_states(self, targets, grip_pos = None, grip = None, wait=True):
        # move to the target joint configuration

        
        if grip_pos is not None:
            for i in range(len(targets)):
                print(i)
                success = self.go_to_joint_state(targets[i], grip_pos[i], grip, wait)
                # go back to reduce the error
                if not success:
                    i -= 2
                    print("failed")
        else:
            for i in range(len(targets)):
                print(i)
                success = self.go_to_joint_state(targets[i], None, None, wait)
                # go back to reduce the error
                if not success:
                    i -= 2
                    print("failed")
            




    def move_through_waypoints(self, targets, grip_pos = None, grip = None, is_joint_pos=False, wait=True):
        '''Uses MoveIt! to generate a plan then move the robot.

        Generates a plan to move the robot through the specified end effector 
        or joint pose waypoints, then moves the robot. Returns True on success,
        otherwise returns False.

        Parameters
        ----------
        targets : list
            a list of either joint positions or end effector positions. 
            See the documentation for plan_joint_waypoints and
            plan_ee_waypoints.
        is_joint_pos : bool, optional
            True if the targets are given in joint space (defaults to False)
        wait : bool, optional
            whether to return immediately or block until movement is complete. 
            Default value is True

        Returns
        ----------
        bool
            True on success
        '''
        cnt = 0
     
        plans = self.plan_waypoints(targets, is_joint_pos)
        if plans == None or len(plans)==0:
            rospy.logwarn('no plans generated')
            return False
        success = True
        for idx, plan in enumerate(plans):
            cnt+=1
            print(cnt)
            success = success and self.move_robot(plan, wait)
            # unfortunate hack. There appears to be a significant settling time
            # for the kinova arm.
            if grip_pos is not None:
                if grip_pos[cnt] > 0.8:
                    grip.close()
                else:
                    grip.open()

            if not is_joint_pos and idx < (len(plans)-1):
                rospy.sleep(0.5)
        return success

    def move_through_joint_waypoints(self, targets):
        '''Uses MoveIt! to generate a plan then move the robot.

        Generates a plan to move the robot through the specified end effector 
        or joint pose waypoints, then moves the robot. Returns True on success,
        otherwise returns False.

        Parameters
        ----------
        targets : list
            a list of joint positions (either list or dict)
            See the documentation for plan_joint_waypoints.

        Returns
        ----------
        bool
            True on success
        '''
        return self.move_through_waypoints(targets, is_joint_pos=True)


    def move_to_joint_pose(self, target):
        '''Uses MoveIt! to generate a plan then move the robot.

        Generates a plan to move the robot to the specified joint pose, 
        then moves the robot. Returns True on success, otherwise returns False.

        Parameters
        ----------
        target : list or dict
            a joint position (list or dict). See the documentation for 
            plan_joint_waypoints.

        Returns
        ----------
        bool
            True on success
        '''
        return self.move_to_pose(target, is_joint_pos=True)

    def move_to_ee_pose(self, target):
        '''Uses MoveIt! to generate a plan then move the robot.

        Generates a plan to move the robot to the specified joint pose, 
        then moves the robot. Returns True on success, otherwise returns False.

        Parameters
        ----------
        target : geometry_msgs/Pose
            an end effector position. See the documentation for 
            plan_ee_waypoints.

        Returns
        ----------
        bool
            True on success
        '''
        return self.move_to_pose(target, is_joint_pos=False)
    
    def move_through_ee_waypoints(self, targets):
        '''Uses MoveIt! to generate a plan then move the robot.

        Generates a plan to move the robot through the specified end effector 
        or joint pose waypoints, then moves the robot. Returns True on success,
        otherwise returns False.

        Parameters
        ----------
        targets : list
            a list of end effector positions (geometry_msgs/Pose)
            See the documentation for plan_ee_waypoints.

        Returns
        ----------
        bool
            True on success
        '''
        return self.move_through_waypoints(targets, is_joint_pos=False)    

    def move_to_pose(self, target, is_joint_pos=False, wait=True):
        '''Uses MoveIt! to generate a plan then move the robot.

        Generates a plan to move the robot to the specified end effector 
        or joint pose, then moves the robot. Returns True on success,
        otherwise returns False.

        Parameters
        ----------
        target : list, dict, or geometry_msgs/Pose
            either a joint position (list or dict) or end effector position. 
            See the documentation for plan_joint_waypoints and
            plan_ee_waypoints.
        is_joint_pos : bool, optional
            True if the targets are given in joint space (defaults to False)
        wait : bool, optional
            whether to return immediately or block until movement is complete. 
            Default value is True

        Returns
        ----------
        bool
            True on success
        '''
        plan = self.plan_pose(target, is_joint_pos=is_joint_pos)
        if plan != None:
            return self.move_robot(plan, wait)
        else:
            return False
    
    def plan_pose(self, target, is_joint_pos=False, starting_config=None):
        '''Plan a trajectory to reach a given end effector or joint pose

        Uses MoveIt! to plan a trajectory to reach a given end effector
        position or joint configuration.

        Parameters
        ----------
        target : list, dict, or geometry_msgs/Pose
            either a joint position (list or dict) or end effector position. 
            See the documentation for plan_joint_waypoints and
            plan_ee_waypoints.
        is_joint_pos : bool, optional
            True if the targets are given in joint space (defaults to False)

        Returns
        ----------
        RobotTrajectory
            the plan for reaching the target position
        '''
        if is_joint_pos:
            return self.plan_joint_pos(target, starting_config)
        else:
            return self.plan_ee_pos(target, starting_config)

    def plan_waypoints(self, targets, is_joint_pos=False
                       ,merge_plans=False, starting_config=None):
        '''Generates a multi-segment plan to reach waypoints in target space
        
        Uses MoveIt! to generate a plan from target to target. One plan is
        generated for each segment.

        .. warning:: The plans can be stitched together, but this can have 
            unexpected issues since the plan boundaries can violate 
            acceleration limits.
        
        Parameters
        ----------
        targets : list
            a list of either joint positions or end effector positions. 
            See the documentation for plan_joint_waypoints and
            plan_ee_waypoints.
        is_joint_pos : bool, optional
            True if the targets are given in joint space (defaults to False)
        merge_plans : bool
            if True, return a single merged plan (see note above about 
            potential issues)
        starting_config : RobotState
            the starting state. If not provided this will default to the 
            current state of the robot.

        Returns
        ----------
        list of RobotTrajectory
            the plan for reaching the target position
        '''
        if is_joint_pos:
            print('joint pos in plan_waypoints')
            plans = self.plan_joint_waypoints(targets, starting_config)
        else:
            plans = self.plan_ee_waypoints(targets, starting_config)
        
        if merge_plans:
            return self._merge_plans(plans)
        else:
            return plans

    def get_current_pose(self, simplify=True, is_dict=True):
        '''Returns the current pose of the planning group
        
        Parameters
        ----------
        simplify : bool, optional
            whether or not to simplify continuous joints into +/- pi

        Returns
        ----------
        dict
            the joint positions, mapped into (-pi,pi) if simplify
        '''
        if not is_dict:
            return self._simplify_joints(self.group.get_current_joint_values())
        if simplify:
            return dict(zip(self.group.get_active_joints(),self._simplify_joints(self.group.get_current_joint_values())))
        else:
            return dict(zip(self.group.get_active_joints(),self.group.get_current_joint_values())) 
        
    def get_current_ee_pose(self, simplify=True):
        """
        Returns the current pose of the end effector of the planning group.

        Parameters:
        simplify (bool, optional): Whether or not to simplify the pose of continuous joints into +/- pi.

        Returns:
        A tuple containing the x, y, and z position of the end effector in meters.
        """


        # Check if the simplify flag is set
        if simplify:
            # Get the current pose of the end effector and simplify it
            ee_pose = self.group.get_current_pose()
            return ee_pose
        else:
            # If the simplify flag is not set, do nothing and return None
            pass



    def get_planning_frame(self):
        '''
        Return
        ---------
        string
            the frame used to initialize the planner
        '''
        return self.group.get_pose_reference_frame()

    def get_eef_frame(self):
        '''
        Return
        ---------
        string
            the frame used to initialize the end-effector link
        '''
        
        return self.group.get_end_effector_link()

    def state_from_joints(self, joints):
        ''' Returns a RobotState object with given joint positions

        Returns a RobotState object with the given joints
        set to the given positions.  The joints may be given
        as a dict or list object.  All other joints are taken from
        the current state.

        Parameters
        ----------
        joints : list or dict
            if a list, a list of positions for all active joints in 
            the group; if a dictionary, a mapping of joint names to 
            positions for the joints that should be moved (all other 
            joints will be held at their current angles).

        Returns
        ----------
        RobotState
            A RobotState object with only the given joints changed
        '''
        state = self._copy_state()
        #print('joints: ' + str(type(joints)))
        simple_joints = self._simplify_joints(joints)
        if isinstance(joints, dict):
            joint_names = joints.keys()
            new_joints = [x for x in state.joint_state.position]
            
            for jname in joint_names:
                new_joints[state.joint_state.name.index(jname)]=simple_joints[jname]
            state.joint_state.position = new_joints
        elif isinstance(joints, list):
            state.joint_state.position = copy.copy(joints)
        else:
            rospy.logerr("Joints must be provided as a list or dictionary")
            raise TypeError("Joints must be provided as a list or dictionary")
        return state

    def state_from_trajectory(self, trajectory, point_idx=-1):
        ''' Returns a RobotState object with joint positions from trajectory

        Returns a RobotState object with joint positions taken from the 
        given trajectory. By default, sets the position to the last point
        in the trajectory.

        Parameters
        ----------
        trajectory : JointTrajectory
            the trajectory from which to take the joint positions.
        point_idx : int
            which point in the trajectory to take the state from. Defaults 
            to -1, taking the last point.

        Returns
        ----------
        RobotState 
            A RobotState object with state corresponding to the
            given point in the trajectory.
        '''

        state = self._copy_state()
        target = trajectory.points[point_idx]
        joints = [x for x in state.joint_state.position]
        for i in range(len(trajectory.joint_names)):
            joint_name = trajectory.joint_names[i]
            idx = state.joint_state.name.index(joint_name)
            joints[idx]=target.positions[i]
        state.joint_state.position = joints
        return state

    def _simplify_angle(self, angle):
        # Very simple function that makes sure the angles are between -pi and pi
        if angle > pi:
            while angle > pi:
                angle -= 2*pi
        elif angle < -pi:
            while angle < -pi:
                angle += 2*pi

        return angle

    def _simplify_joints(self, joints):
        # Helper function to convert a dictionary of joint values
        if isinstance(joints, dict):
            simplified_joints = dict()
            for joint in joints:
                # Pull out the name of the joint
                joint_name = '_'.join(joint.split('_')[1::])
                if joint_name in self.continuous_joints:
                    simplified_joints[joint] = self._simplify_angle(joints[joint])
                else:
                    simplified_joints[joint] = joints[joint]
        elif isinstance(joints, list):
            simplified_joints = []
            #separate the joint name from the group name
            joint_order = [ "_".join(s.split("_")[1::]) for s in self.group.get_active_joints() ]
            
            continuous_joint_indices = [joint_order.index(j) for j in self.continuous_joints]

            for i in range(len(joints)):
                a = joints[i]
                if i in continuous_joint_indices:
                    simplified_joints.append(self._simplify_angle(a))
                else:
                    simplified_joints.append(a)
        else:
            rospy.logerr("Joints must be provided as a list or dictionary")
            raise TypeError("Joints must be provided as a list or dictionary")
        return simplified_joints

    def _copy_state(self):
        ''' Copies the robot state (so it can be modified to plan from
            non-current joint configurations).'''
        ## output: a copy of the robot's current state
        current_state = self.robot.get_current_state()
        for name, state in zip(current_state.joint_state.name, current_state.joint_state.position):
            print("%s %.2f" % (name, state))
        return copy.deepcopy(self.robot.get_current_state())

    def _merge_plans(self, plan_list, time_between=0.1):
        #check if the list is empty
        if plan_list==None or len(plan_list)==0:
            rospy.logwarn("Cannot merge plans: no plans provided")
            return plan_list
        
        all_points = []
        start_time = rospy.Duration(0)
        for plan in plan_list:
            for point in plan.joint_trajectory.points:
                new_point = copy.deepcopy(point)
                new_point.time_from_start = new_point.time_from_start+start_time
                all_points.append(new_point)
            start_time=all_points[-1].time_from_start+rospy.Duration(time_between)
                
        full_plan = copy.deepcopy(plan_list[0])
        full_plan.joint_trajectory.points=all_points
        return full_plan


    ''' Deprecated function definitions maintained for backwards compatibility '''

    def plan_targetInput(self, target, joint_flag):
        '''***DEPRECATED*** Generic target planner that what type is specified'''
        if (joint_flag):
            self.plan_joint_pos(target)
        else:
            self.plan_ee_pos(target)

    def plan_targetInputWaypoint(self, targets, joint_flag, merged=False, 
                                 current_joints=None):
        '''***DEPRECATED*** Left in for backwards compatibility'''
        return self.plan_waypoints(targets, joint_flag, 
                                   merged, current_joints)

    def set_robot_state_pose(self, traj):
        '''***DEPRECATED*** Left in for backwards compatibility'''
        return self.state_from_trajectory(traj, point_idx=-1)

    def set_robot_state_joint_dict(self, joint_dict):
        '''***DEPRECATED*** Left in for backwards compatibility'''
        return self.state_from_joints(joint_dict)
    
    def get_active_joints(self):
        '''***DEPRECATED*** Left in for backwards compatibility'''
        return self.group.get_active_joints()

    def merge_points(self, points, new_points, time_between=0.1):
        '''***DEPRECATED*** Left in for backwards compatibility'''
        # Check if this is the first set
        if len(points) < 1:
            return new_points

        all_points = points
        # Pull out the last time from current points
        last_point_time = points[-1].time_from_start+rospy.Duration(time_between)
        for point in new_points:
            point.time_from_start = point.time_from_start+last_point_time
            all_points = all_points + [point]
        return all_points

    def plan_jointTargetInput(self,target_joint):
        '''***DEPRECATED*** Left in for backwards compatibility'''
        ## input: target joint angles (list) of the robot
        ## output: plan from current joint angles to the target one
        return self.plan_joint_pos(target_joint)

    def plan_poseTargetInput(self,target_pose):
        '''***DEPRECATED*** Left in for backwards compatibility'''
        ## input: tart pose (geometry_msgs.msg.Pose())
        ## output: plan from current  pose to the target one
        return self.plan_ee_pos(target_pose)
        
    def box_table_scene(self):
        '''***DEPRECATED*** Left in for backwards compatibility'''
        #Scene : add box 
        # after loading this object/scene, need to do "add" ==> "planning scene"  
        # in the rviz interface if one want to see the box
        
        rospy.sleep(2)
        self.scene.remove_world_object("table_box")
        
        p = geometry_msgs.msg.PoseStamped()
        p.header.frame_id = self.robot.get_planning_frame()
        p.pose.position.x = 1.64
        p.pose.position.y = 0.0
        p.pose.position.z = 0.25
        p.pose.orientation.w = 0.0
        self.scene.add_box("table_box",p,(0.75, 1, 0.5))
     
        rospy.sleep(5)

    def wayPointIK(self, wps, numSteps = None, ik_root = None):
        '''***DEPRECATED*** Left in for backwards compatibility'''
        if numSteps is None:
            numSteps = 3
            jointWps = []

        for i in range(0, len(wps)):
            jointP = self.get_IK(wps[i], ik_root)
            if jointP is None:
                jointWps = None
                break
            jointWps.append(jointP)

        return jointWps

def ask_scene_integration(arm):
    # Ask the user if want to integrate a box scene
    answer= input("""\n Integrate a box as a table from code ? (1 or 0)  
  (if 1: box can't be displaced nor resized by user, if 0: no scene (can always do add from rviz interface) ) \n""")
    
    if answer == 1:
        arm.box_table_scene()
        print("\n Box inserted; to see it ==> rviz interface ==> add button==> planning scene  ")
        return
    else:
        print("\n No scene added")
        return  
      
def ask_position(arm,tarPose):
    #Ask the user the values of the target position
    while True:
        try:   
            inputPosition=input(""" \n Target position coord. (format: x,y,z or write -1 to take the robot current position ): """)      
            
            if inputPosition == -1:
                inputPosition=tarPose.position  
                return inputPosition
          
        except (ValueError,IOError,NameError):
            print("\n Please, enter the coordinate in the following format: x,y,z ")
            continue
        else:          
            if len(list(inputPosition)) == 3:
                poseTmp= geometry_msgs.msg.Pose()
                poseTmp.position.x=inputPosition[0]
                poseTmp.position.y=inputPosition[1]
                poseTmp.position.z=inputPosition[2]
                return poseTmp.position
            else:
                print("\n Please, enter the coordinate in the following format: x,y,z ")
                continue
            
        
def ask_orientation(arm,tarPose):
    # Ask the user the values of the target quaternion
    while True:
        try:   
            inputQuat=input(""" \n Target quaternion coordi. (format: qx,qy,qz,qw or write -1 to take the robot current quaternion ):""")
            
            if inputQuat == -1:
                inputQuat=arm.group.get_current_pose().pose.orientation                   
            return  inputQuat
          
        except (ValueError,IOError,NameError):
            print("\n Please, enter the coordinate in the following format: qx,qy,qz,qw ")
            continue
        else:
            if len(list(inputQuat)) == 4:
                poseTmp= geometry_msgs.msg.Pose()
                poseTmp.orientation.x=inputQuat[0]
                poseTmp.orientation.y=inputQuat[1]
                poseTmp.orientation.z=inputQuat[2]
                poseTmp.orientation.w=inputQuat[3]
                return poseTmp.orientation    
            else:
                print("\n Please, enter the coordinate in the following format: qx,qy,qz,qw ")
            
def main():
    arm = Arm()

    tarPose = geometry_msgs.msg.Pose()

    ## ask if integrate object scene from code or not
    ask_scene_integration(arm)
    
    while not rospy.is_shutdown():
      
        ##   Assigned tarPose the current Pose of the robot 
        tarPose = arm.group.get_current_pose().pose
      

        ## ask input from user (COMMENT IF NOT USE AND WANT TO ASSIGN MANUAL VALUE IN CODE)    
        tarPose.position = ask_position(arm,tarPose)   
        tarPose.orientation = ask_orientation(arm,tarPose)  

        ##  Example of Assigned values for new targetPose to robot
        #    tarPose.position.x = 0.89
        #    tarPose.position.y = 0.00
        #    tarPose.position.z = 0.32   
        #    tarPose.orientation.x = 0.0     
   
        print('\n The target coordinate is: %s \n' %tarPose )
    
        ## IK for target position  
        jointTarg = arm.get_IK(tarPose)
        print('IK calculation step:DONE' )
    
        ## planning with joint target from IK 
        planTraj =  arm.plan_jointTargetInput(jointTarg)
        print('Planning step with target joint angles:DONE')
    
        ## planning with pose target
        #print 'Planning step with target pose'   
        #planTraj = arm.plan_poseTargetInput(tarPose)
    
        ## execution of the movement   
        #print 'Execution of the plan' 
        # arm.group.execute(planTraj)
    
if __name__ == '__main__':
    ## First initialize moveit_commander and rospy.
    moveit_commander.roscpp_initialize(sys.argv)
    rospy.init_node('vector_basic_IK', anonymous=True)
    
    main()
----------------------------------------------------------------------------
#kortex arm.py

"""
File for doing manipulation stuff with the arm.
Largely uses code from ros_kortex

Author: Isaac Sheidlower, AABL Lab, Isaac.Sheidlower@tufts.edu
"""
import copy
from math import radians
import message_filters
import threading
from turtle import pos
import numpy as np
import sys
import rospy
import time
from moveit_msgs.srv import GetPositionFK, GetPositionIK, GetPositionIKRequest, GetPositionIKResponse
from moveit_msgs.msg import RobotState, PositionIKRequest
from sensor_msgs.msg import JointState
import geometry_msgs.msg
from tf.transformations import quaternion_from_euler, euler_from_quaternion
import tf.transformations as tfs
from kortex_driver.srv import *
from kortex_driver.msg import *

try:
    import aiorospy
except ImportError:
    HAS_AIOROSPY = False
else:
    HAS_AIOROSPY = True
    import asyncio


#############
## PARSING/CONVERTING MESSAGES
##############
def pose_to_kortex_pose(pose):
    # cheap and dirty way to accept PoseStamped
    if hasattr(pose, "pose"):
        pose = pose.pose

    rpy = np.rad2deg(euler_from_quaternion((
        pose.orientation.x,
        pose.orientation.y,
        pose.orientation.z,
        pose.orientation.w
    )))

    return Pose(
        x = pose.position.x,
        y = pose.position.y,
        z = pose.position.z,
        theta_x = rpy[0],
        theta_y = rpy[1],
        theta_z = rpy[2]
    )

def pose_tf_to_kortex_pose(pose):
    p = tfs.translation_from_matrix(pose)
    r = np.rad2deg(tfs.euler_from_matrix(pose))
    return Pose(*p, *r)

def pose_pq_to_kortex_pose(p, q):
    return Pose(*p, *np.rad2deg(tfs.euler_from_quaternion(q)))

def kortex_pose_to_position_euler(pose, prefix=""):
    return (
        (getattr(pose, prefix+"x"),
            getattr(pose, prefix+"y"),
            getattr(pose, prefix+"z")),
        np.deg2rad((
            getattr(pose, prefix+"theta_x"), 
            getattr(pose, prefix+"theta_y"),
            getattr(pose, prefix+"theta_z"))
        )
    )

def kortex_pose_to_pose(pose, prefix):
    p, r = kortex_pose_to_position_euler(pose, prefix)
    return geometry_msgs.msg.Pose(
        position = geometry_msgs.msg.Point(*p),
        orientation = geometry_msgs.msg.Quaternion(*tfs.quaternion_from_euler(*r))
    )

def kortex_pose_to_transformation_matrix(pose, prefix):
    p, r = kortex_pose_to_position_euler(pose, prefix)
    return tfs.concatenate(
        tfs.translation_matrix(p),
        tfs.euler_matrix(*r)
    )

def parse_pose_input(pose):
    ## parse pose input
    if isinstance(pose, (geometry_msgs.msg.Pose, geometry_msgs.msg.PoseStamped)):
        if isinstance(pose, geometry_msgs.msg.PoseStamped):
            pose = pose.pose
        p = (pose.position.x, pose.position.y, pose.position.z)
        q = (pose.orientation.x, pose.orientation.y, pose.orientation.z, pose.orientation.w)
    elif isinstance(pose, (list, np.ndarray)):
        p = pose[:3]
        if len(pose[3:]) == 0:
            q = [0, 0, 0, 1]
        elif len(pose[3:]) == 3:
            # euler angles, always radians
            q = quaternion_from_euler(pose[3:])
        elif len(pose[3:]) == 4:
            # TODO: validate
            q = pose[3:]
        else:
            raise ValueError(f"values as pose must be length 3, 6, or 7, got {pose}")
    else:
        raise ValueError(f"Unknown pose input: {pose}")
    return p, q

# TODO: figure out how to do this and deal with frame_id
# try:
#     import tf2_ros
# except ImportError:
#     pass
# else:
#     tf2_ros.ConvertRegistration().add_


# set up services for lazy definition/acquisition
# is this too fancy? idk seems not ideal to set up all dozens of services if unused
_KORTEX_SERVICES = {
    "compute_fk": ("/compute_fk", GetPositionFK),
    "compute_ik": ("/compute_ik", GetPositionIK),
    "get_product_configuration": ("/base/get_product_configuration", GetProductConfiguration),
    "read_sequence": ("/base/read_sequence", ReadSequence),
    "read_all_sequences": ("/base/read_all_sequences", ReadAllSequences),
    "play_sequence": ("/base/play_sequence", PlaySequence)
}

_DEFAULT_DOF = {
    "gen3": 7,
    "gen3_lite": 6
}

class Arm:
    HOME_ACTION_IDENTIFIER = 2

    def __init__(self, robot_name=None):
        rospy.loginfo(f"Loading robot {robot_name}")

        # figure out which robot we are, gen3 or gen3_lite
        # step 1: use arm_name
        if robot_name is not None:
            # easy?
            self.robot_name = robot_name
            self.degrees_of_freedom = _DEFAULT_DOF.get(robot_name)
        else:
            # no arm_name provided
            # next place to check is the parameter server
            # TODO: do we want search_param instead?
            self.robot_name = rospy.get_param('~robot_name', default=None)

            if self.robot_name is None:
                # no dice, let's make some guesses

                if rospy.has_param('/my_gen3_lite/robot_description'):
                    # a gen3_lite exists in ROS under the default loaded name, so let's use it
                    self.robot_name = "/my_gen3_lite"
                    self.degrees_of_freedom = 6
                elif rospy.has_param('/my_gen3/robot_description'):
                    # we found a gen3
                    self.robot_name = "/my_gen3"
                    self.degrees_of_freedom = 7
                else:
                    # TODO: maybe something fancier?
                    raise ValueError("Failed to find which kortex arm is specified")


        self.degrees_of_freedom = rospy.get_param(
            f"{self.robot_name}/degrees_of_freedom", self.degrees_of_freedom)
        # self.is_gripper_present = rospy.get_param(f"{self.robot_name}/is_gripper_present")
        # no defaults on these -- if these don't exist, the robot parameters are configured
        # in a way we don't understand, so we should quit
                

        rospy.loginfo(f"Using robot_name {self.robot_name}, robot has {self.degrees_of_freedom}")
                        # f" degrees of freedom and is_gripper_present is {self.is_gripper_present}")


        # Init the action topic subscriber
        self.action_topic_sub = rospy.Subscriber(
            f"{self.robot_name}/action_topic", ActionNotification, self.cb_action_topic)
        self.last_action_notif_type = None

        # Init a bunch of services
        # TODO: maybe do this lazily? idk if it's worth it

        # set up commonly used services
        # Any service that can be called directly *without* importing a kortex srv/msg we can
        # just alias the function to the service call

        # basic actions -- always set these up
        # TODO: can just create these through __getattr__ 
        self.clear_faults_service = rospy.ServiceProxy(
            f"{self.robot_name}/base/clear_faults", Base_ClearFaults)
        self.clear_faults = self.clear_faults_service.call
        self.stop_service = rospy.ServiceProxy(
            f"{self.robot_name}/base/stop", Stop)
        self.stop = self.stop_service.call
        self.estop_service = rospy.ServiceProxy(
            f"{self.robot_name}/base/apply_emergency_stop", ApplyEmergencyStop)
        self.estop = self.estop_service.call

        # more complex configs -- now using _service
        self.set_cartesian_reference_frame_service = rospy.ServiceProxy(
            f'{self.robot_name}/control_config/set_cartesian_reference_frame', SetCartesianReferenceFrame)


        self.read_action_service = rospy.ServiceProxy(
            f"{self.robot_name}/base/read_action", ReadAction)
        self.execute_action_service = rospy.ServiceProxy(
            f"{self.robot_name}/base/execute_action", ExecuteAction)
        self.activate_publishing_of_action_notification_service = rospy.ServiceProxy(
           f'{self.robot_name}/base/activate_publishing_of_action_topic', OnNotificationActionTopic)
        
        self.send_gripper_command_service = rospy.ServiceProxy(
            f'{self.robot_name}/base/send_gripper_command', SendGripperCommand)

        self.validate_waypoint_list_service = rospy.ServiceProxy(
            f'{self.robot_name}/base/validate_waypoint_list', ValidateWaypointList)
        
        
        # setup defult translation and orientation speed
        # when moving in cartesian space

        self.cartesian_speed = CartesianSpeed()
        self.cartesian_speed.translation = .1  # m/s
        self.cartesian_speed.orientation = 15  # deg/s

        # set up basics
        self.clear_faults()
        self.set_cartesian_reference_frame()

        # TODO: don't do this! the kortex docs say that sending this msg strains the system
        # and you shouldn't leave it active all the time
        # basic solution: make a context manager to activate/deactivate and hope there's only one at a time (or enforce)
        # complex solution: reference counting
        self.subscribe_to_a_robot_notification()

    def cb_action_topic(self, notif):
        self.last_action_notif_type = notif.action_event

    def __getattr__(self, attr):
        """
        Autocreate services and callables if they don't exist
        """
        if attr in _KORTEX_SERVICES:
            if not hasattr(self, attr+"_service"):        
                topic, msgtype = _KORTEX_SERVICES[attr]
                service = rospy.ServiceProxy(self.robot_name + topic, msgtype)
                setattr(self, f"{attr}_service", service)
            else:
                service = getattr(self, attr+"_service")
            setattr(self, attr, service.call)
            return service.call
        elif attr.endswith("_service") and attr.removesuffix("_service") in _KORTEX_SERVICES:
            base_attr = attr.removesuffix("_service")
            topic, msgtype = _KORTEX_SERVICES[base_attr]
            service = rospy.ServiceProxy(self.robot_name + topic, msgtype)
            # no attr was requested so just create the service
            setattr(self, attr, service)
            return service
        else:
            raise AttributeError(f"{type(self)} object has no attribute {attr}")

    def FillCartesianWaypoint(self, new_x, new_y, new_z, new_theta_x, new_theta_y, new_theta_z, blending_radius):
        """
        Note: not sure what blending_radius is but defaulting to zero everywhere this function is called
        """
        waypoint = Waypoint()
        cartesianWaypoint = CartesianWaypoint()

        cartesianWaypoint.pose.x = new_x
        cartesianWaypoint.pose.y = new_y
        cartesianWaypoint.pose.z = new_z
        cartesianWaypoint.pose.theta_x = new_theta_x
        cartesianWaypoint.pose.theta_y = new_theta_y
        cartesianWaypoint.pose.theta_z = new_theta_z
        cartesianWaypoint.reference_frame = CartesianReferenceFrame.CARTESIAN_REFERENCE_FRAME_BASE
        cartesianWaypoint.blending_radius = blending_radius
        waypoint.oneof_type_of_waypoint.cartesian_waypoint.append(
            cartesianWaypoint)

        return waypoint

    async def action_complete(self, action, message_timeout=None):
        """
        Coroutine to block until an action is complete. TODO: use context manager to activate/deactivate
        sending these msgs

        message_timeout: Duration to wait for a notification on the action_topic topic
            NB: by default, actions only send messages at status change, so can be used as a global timeout
            for simple actions

        Raises:
            TimeoutError: No message received or rospy shutdown
            CancelledError: Action aborted or rospy shutdown
        """

        if not HAS_AIOROSPY:
            raise NotImplementedError()

        topic = f"{self.robot_name}/action_topic"
        action_event_sub = aiorospy.AsyncSubscriber(f"{self.robot_name}/action_topic", ActionNotification, 
                                                   queue_size=10) # always get newest message
        sub_iter = action_event_sub.subscribe().__aiter__()
        try:
            # let things initialize
            self.execute_action_service(action)
            while not rospy.is_shutdown():
                evt = await asyncio.wait_for(sub_iter.__anext__(), message_timeout)
                if evt.action_event == ActionEvent.ACTION_END:
                    return True
                elif evt.action_event == ActionEvent.ACTION_ABORT:
                    raise asyncio.CancelledError()
        # shut down the generator -- therefore the subscriber
        finally:
            await sub_iter.aclose()
            
        # rospy shutdown
        raise asyncio.CancelledError()

    
    async def robot_stopped(self, message_timeout=None, tolerance=0.01, stop_duration=0.25):
        """
        Catchall awaitable for robot motion
        TODO: merge with gripper motion
        """

        if not HAS_AIOROSPY:
            raise NotImplementedError()
        
        pos_sub = aiorospy.AsyncSubscriber(f"{self.robot_name}/base_feedback/joint_state", JointState, 
                                                   queue_size=1) # always get newest message
        sub_it = pos_sub.subscribe().__aiter__()
        last_tm = None
        try:
            while not rospy.is_shutdown():
                msg = await asyncio.wait_for(sub_it.__anext__(), message_timeout)
                # todo: check that velocity is also ~0?
                # TODO: actual values are very different from set values
                # send 1 -> joint ~0.95
                # send 0 -> joiny ~-0.09
                # so let's just wait for it to settle
                #
                # if np.abs(msg.position[self.degrees_of_freedom] - value) < tolerance:
                #     return True
                if np.all(np.abs(msg.velocity) <= tolerance):
                    if last_tm is None:
                        last_tm = msg.header.stamp
                    if (msg.header.stamp - last_tm).to_sec() >= stop_duration:
                        return True
                else:
                    last_tm = None
                        
        # shut down the generator -- therefore the subscriber
        finally:
            await sub_it.aclose()

        # rospy shutdown
        raise asyncio.CancelledError()



    def wait_for_action_end_or_abort(self):
        """
        Function to wait for an action to end or abort based on
        kinovas action topics. If this is not called, then there is
        a chance that proceeding action requests will not be executed.
        """
        while not rospy.is_shutdown():
            if (self.last_action_notif_type == ActionEvent.ACTION_END):
                rospy.loginfo("Received ACTION_END notification")
                return True
            elif (self.last_action_notif_type == ActionEvent.ACTION_ABORT):
                rospy.loginfo("Received ACTION_ABORT notification")
                self.all_notifs_succeeded = False
                return False
            else:
                rospy.sleep(0.01)

    def subscribe_to_a_robot_notification(self):
        # Activate the publishing of the ActionNotification
        #
        # TODO: implement req args
        req = OnNotificationActionTopicRequest()
        return self.activate_publishing_of_action_notification_service(req)

    def execute_action(self, action, block=True, coro=False, *coro_args, **coro_kwargs):
        # TODO: something with monitoring specific actions/actionhandles
        # TODO: make actions cancelable/pausable
        if block:
            # set up polling for notifications
            # TODO: make better
            self.subscribe_to_a_robot_notification()
            self.last_action_notif_type = None

            self.execute_action_service(action)

            return self.wait_for_action_end_or_abort()
        elif coro:
            self.subscribe_to_a_robot_notification()
            return self.action_complete(action, *coro_args, **coro_kwargs)
        else:
            self.execute_action_service(action)

    def home_arm(self, **call_args):
        # The Home Action is used to home the robot. It cannot be deleted and is always ID #2:
        req = ReadActionRequest()
        req.input.identifier = Arm.HOME_ACTION_IDENTIFIER
        res = self.read_action_service(req)

        # Execute the HOME action we just read
        return self.execute_action(res.output, **call_args)

    def play_named_sequence(self, name, *args, **kwargs):
        all_seqs = self.read_all_sequences()
        seq = [ s.handle for s in all_seqs.output.sequence_list if s.name==name ]
        if len(seq) == 0:
            raise ValueError(f"Unknown sequence name: {name}")
        elif len(seq) > 1:
            raise ValueError(f"Multiple sequences corresponding to name: {name}")
        
        return self.play_sequence(seq[0], *args, **kwargs)

    def get_ik(self, pose=None, check_collisions=True):
        """
        Returns list of joints for a given pose. If no pose is give,
        will return ik for current joints. If no IK solution is found
        will return -1. If the pose is in collision, will return -2. 

        pose: list, numpy array, or PoseStamped message
        If list or numpy array, first three positions should be x,y,z position
        and next for positions should be x,y,z,w in quaternian. 
        """

        if isinstance(pose, geometry_msgs.msg.PoseStamped):
            pose_stamped = pose
        elif pose is None:
            pose = self.get_eef_pose()
            pose_stamped = geometry_msgs.msg.PoseStamped(pose)
        else:
            p, q = parse_pose_input(pose)
            pose = geometry_msgs.msg.Pose(
                position=geometry_msgs.msg.Point(*p),
                orientation=geometry_msgs.msg.Quaternion(*q)
            )
            pose_stamped = geometry_msgs.msg.PoseStamped(pose)

        # with moveit
        ik_req = PositionIKRequest(
            group_name="arm",
            pose_stamped=pose_stamped,
            avoid_collisions=check_collisions
        )
        ik_req.robot_state.is_diff = True

        ik_result = self.compute_ik_service(ik_req)
        if ik_result.error_code.val == -31:
            return -1
        elif ik_result.error_code.val == -12:
            return -2
        else:
            return ik_result.solution.joint_state.position[0:self.degrees_of_freedom]
            
    def get_fk(self, joints=None):
        """
        Returns fk of joints as a PoseStamped message. If no 
        fk solution is found will return -1.

        joints: list or dictionary of joints, 
            lists are assumed to be in order of joint1-6/7
        """

        if joints is None:
            joint_state = rospy.wait_for_message(
                f"/{self.robot_name}/joint_states", JointState)
        else:
            joint_state = JointState()
            if isinstance(joints, list):
                joint_state.name = [f"joint{i+1}" for i in range(self.degrees_of_freedom)]
                joint_state.position = joints
            else:
                joint_state.name = list(joints.keys())
                joint_state.position = [joints[n] for n in joint_state.name]   # order is not technically guaranteed

        result = self.compute_fk_service(
            fk_link_names=['tool_frame'], robot_state=RobotState(joint_state=joint_state))
        if result.error_code.val != 1:
            return -1
        else:
            return result.pose_stamped[0]

    def get_eef_pose(self, quaternion=True):
        """
        Returns current eef pose as a PoseStamped if quaternion is True,
        otherwise returns a list of [x,y,z,theta_x,theta_y,theta_z] in radians
        """
        data = rospy.wait_for_message(
            f"{self.robot_name}/base_feedback", BaseCyclic_Feedback)
        if quaternion:
            return geometry_msgs.msg.PoseStamped(pose=kortex_pose_to_pose(data.base, prefix="tool_pose_"))
        else:
            p, r = kortex_pose_to_position_euler(data.base, prefix="tool_pose_")
            return [*p, *r]
            
    def get_joint_angles(self):
        """
        Returns current joints as a list in order of joints
        """
        joint_states = rospy.wait_for_message(
            f"{self.robot_name}/joint_states", JointState)

        return joint_states.position[:self.degrees_of_freedom]

    def set_cartesian_reference_frame(self):
        # Prepare the request with the frame we want to set)
        req = SetCartesianReferenceFrameRequest()
        req.input.reference_frame = CartesianReferenceFrame.CARTESIAN_REFERENCE_FRAME_MIXED
        return self.set_cartesian_reference_frame_service(req)

    def goto_cartesian_pose(self, pose, relative=False, check_collision=False,
                            translation_speed=None, orientation_speed=None, **call_args):
        """
        Function that goes to a cartesian pose using ros_kortex's provided interface.
        pose: list, numpy array, or PoseStamped message
            If list or numpy array, can have length 3, 6, or 7.
            First three positions should be x,y,z position
            Remaining 3 are treated as euler angles or remaining for as x,y,z,w quaternion

        relative: If relative is False, the arm will go to the cartesian pose specified
        by the "pose" argument. Else if relative is true, then the the arms current cartesian 
        pose will be incremented with the passed "pose" argument.

        check_collision: If check_collision=True, the function will check if 
        the robot is in collision and return -1. If it is not in collision it will return 1.

        block: If wait_for_end=True, the function will return only after the action
        is completed or the action aborts.

        if translation_speed(m/s) or orientation_speed(deg/s) is not None, the default will be used.


        TODO: fill out the functionality of the remaining arguments
        """

        ## parse pose input
        p, q = parse_pose_input(pose)

        # build pose output
        constrained_pose = ConstrainedPose()

        if relative:
            # complicated -- we need to build the new position from the old
            # unfortunately rotation composition needs to be done with homogeneous matrices
            cur_pose = self.get_eef_pose(quaternion=False)
            cur_pose_tf = tfs.concatenate(
                tfs.translation_matrix(cur_pose[:3]),
                tfs.matrix_from_euler(*cur_pose[3:])
            )
            offset_pose_tf = tfs.concatenate(
                tfs.translation_matrix(p),
                tfs.matrix_from_quaternion(q)
            )
            target_pose = np.dot(offset_pose_tf, cur_pose_tf)
            constrained_pose.target_pose = pose_tf_to_kortex_pose(target_pose)
        else:
            constrained_pose.target_pose = pose_pq_to_kortex_pose(p, q)

        # speed
        cartesian_speed = copy.deepcopy(self.cartesian_speed)
        if translation_speed is not None:
            cartesian_speed.translation = translation_speed
        if orientation_speed is not None:
            cartesian_speed.orientation = orientation_speed
        constrained_pose.constraint.oneof_type.speed.append(cartesian_speed)

        # assemble action
        req = ExecuteActionRequest()
        req.input.oneof_action_parameters.reach_pose.append(constrained_pose)
        req.input.name = "pose"
        req.input.handle.action_type = ActionType.REACH_POSE
        req.input.handle.identifier = 1001

        return self.execute_action(req, **call_args)
    
    def goto_eef_pose(self, pose, *args, **kwargs):
        """
        Function that goes to a cartesian pose using ros_kortex's provided interface.
        pose: list, numpy array, or PoseStamped message
            If list or numpy array, first three positions should be x,y,z position
            and next for positions should be x,y,z,w in quaternian. 
        TODO: add functionality for different eef frames
        """
        return self.goto_eef_waypoints([pose], *args, **kwargs)

    def goto_joint_pose(self, joints, *args, **kwargs):
        """
        Sends the arm to the specified joint angles. 
        joints: list of joint anlges (from 1 to 7 or from 1 to 6 for lite)
        radians: If true, angles will be considered in radians, 
            default is degrees.
        TODO: add dictionary functionality
        """
        return self.goto_joint_waypoints([joints], *args, **kwargs)

    def goto_zero(self, block=True):
        """
            Sends the arm fully vertical where all the joints are zero.
        """
        return self.goto_joint_pose([0 for _ in range(self.degrees_of_freedom)])

    def build_cartesian_waypoint_list(self, waypoints, blending_radius=0):
        trajectory = WaypointList()

        for pose in waypoints:
            p, q = parse_pose_input(pose)
            cart_waypoint = CartesianWaypoint(
                pose=pose_pq_to_kortex_pose(p, q),
                reference_frame=CartesianReferenceFrame.CARTESIAN_REFERENCE_FRAME_BASE, 
                blending_radius=blending_radius,
                maximum_linear_velocity=self.cartesian_speed.translation,
                maximum_angular_velocity=self.cartesian_speed.orientation
            )
            waypoint = Waypoint()
            waypoint.oneof_type_of_waypoint.cartesian_waypoint.append(cart_waypoint)
            trajectory.waypoints.append(waypoint)
        
        return trajectory
    
    def build_angular_waypoint_list(self, waypoints):
        trajectory = WaypointList()

        for i, joints in enumerate(waypoints):
            if len(joints) != self.degrees_of_freedom:
                raise ValueError(f"Unexpected length for waypoint {i}: {len(joints)}, expected {self.degrees_of_freedom}")
            waypoint = Waypoint()
            angularWaypoint = AngularWaypoint(
                angles = np.rad2deg(joints),
                duration = 0
            )
            # Initialize Waypoint and WaypointList
            waypoint.oneof_type_of_waypoint.angular_waypoint.append(
                angularWaypoint)

            trajectory.waypoints.append(waypoint)
        
        return trajectory
    
    def time_waypoint_list(self, trajectory, max_duration=30):
        ### TODO: need to do some testing if this is necessary/how to fix

        duration = 0
        while True:
            resp = self.validate_waypoint_list_service(trajectory)
            errs = resp.output.trajectory_error_report.trajectory_error_elements
            if len(errs) == 0:
                return trajectory # TODO: use optimal_waypoint_list?

            # increment the duration of each waypoint to see if that helps
            duration += 0.2
            if duration > max_duration:
                # TODO: better error type
                raise RuntimeError("Duration limit exceeded when validation trajectory")
            for waypoint in trajectory.waypoints:
                waypoint.oneof_type_of_waypoint.angular_waypoint[0].duration += 0.2
    def goto_eef_waypoints(self, waypoints, blending_radius=0, duration=0, use_optimal_blending=False, **call_args):
        """
            Send the arm through a list of waypoints. 
            Each waypoint may be list, numpy array, or a list of PoseStamped messages
            TODO: add functionality for different eef frames
        """
        trajectory = self.build_cartesian_waypoint_list(waypoints, blending_radius)

        req = ExecuteActionRequest()
        req.input.duration = duration
        req.input.use_optimal_blending = use_optimal_blending
        req.input.oneof_action_parameters.execute_waypoint_list.append(
            trajectory)

        # Call the service
        self.execute_action(req, call_args)

    def goto_joint_waypoints(self, waypoints, max_duration=30, **kwargs):
        """
        NOTE: Currently this is not functional, not sure why it does not work. 

        Sends the arm to the specified series joint angles. 
        joints: list of joint anlges (from 1 to 7)
        TODO: add dictionary functionality
        """

        req = ExecuteActionRequest()

        trajectory = self.build_angular_waypoint_list(waypoints)
        trajectory = self.time_waypoint_list(trajectory, max_duration)

        req.input.oneof_action_parameters.execute_waypoint_list.append(
            trajectory)

        # Send the angles
        return self.execute_action(req, **kwargs)
    
    def close_gripper(self, **kwargs):
        """
        Fully closes the gripper
        """
        return self.send_gripper_command(1., relative=False, mode="position", **kwargs)

    def open_gripper(self, **kwargs):
        """
        Fully opens the gripper.
        """
        return self.send_gripper_command(0., relative=False, mode="position", **kwargs)

    def send_gripper_command(self, value, relative=False, mode="position", duration=None, block=True, coro=False, **coro_args):
        """
        Closes/opens the griper to the specified value. 
        The value is between 0 (fully open) and 1 (fully closed)

        duration in milliseconds, only used in speed mode
        """
        req = SendGripperCommandRequest()
        finger = Finger()
        finger.finger_identifier = 0
        if relative is False:
            finger.value = value
        else:
            finger.value = value + self.get_gripper_position()
        req.input.gripper.finger.append(finger)
        if mode == "position":
            req.input.mode = GripperMode.GRIPPER_POSITION
        elif mode == "speed":
            req.input.mode = GripperMode.GRIPPER_SPEED
            req.input.duration = duration
        elif mode == "force":
            req.input.mode = GripperMode.GRIPPER_FORCE

        rospy.loginfo("Sending the gripper command...")

        # Call the service
        self.send_gripper_command_service(req)
        if block:
            if mode == "position":
                rospy.sleep(1.)
            elif mode == "speed":
                rospy.sleep(duration)
        elif coro:
            if mode == "position":
                return self.gripper_command_complete(value, **coro_args)
            elif mode == "speed":
                return asyncio.sleep(duration)
    
    def get_gripper_position(self):
        """
        Returns the position of the gripper in the range 0 (open) to 1 (closed)
        """
        if self.degrees_of_freedom == 7:
            return rospy.wait_for_message(f"{self.robot_name}/base_feedback/joint_state", JointState).position[7]
        else:
            return rospy.wait_for_message(f"{self.robot_name}/base_feedback/joint_state", JointState).position[6]
        
    async def gripper_command_complete(self, value, message_timeout=1, tolerance=1e-3):
        """
        asyncio coroutine that sends a gripper command and then waits for the gripper value to match
        recommended to wrap this in an asyncio.wait_for

        value: gripper value to send
        message_timeout: duration (sec) to wait for a joint state message
        tolerance: value tolerance to say location has been reached

        raises:
            TimeoutError: if a JointState message is not received within message_timeout
            CancelledError: if rospy is shut down before goal is reached
                Note that due to timeout effects, it is indeterminate whether TimeoutError or
                CancelledError will be called if rospy is shutdown
        """
        if not HAS_AIOROSPY:
            raise NotImplementedError()
        

        gripper_pos_sub = aiorospy.AsyncSubscriber(f"{self.robot_name}/base_feedback/joint_state", JointState, 
                                                   queue_size=1) # always get newest message
        sub_it = gripper_pos_sub.subscribe().__aiter__()
        try:
            while not rospy.is_shutdown():
                msg = await asyncio.wait_for(sub_it.__anext__(), message_timeout)
                # todo: check that velocity is also ~0?
                # TODO: actual values are very different from set values
                # send 1 -> joint ~0.95
                # send 0 -> joiny ~-0.09
                # so let's just wait for it to settle
                #
                # if np.abs(msg.position[self.degrees_of_freedom] - value) < tolerance:
                #     return True
                if np.abs(msg.velocity[self.degrees_of_freedom]) <= tolerance:
                    return True
        # shut down the generator -- therefore the subscriber
        finally:
            await sub_it.aclose()

        # rospy shutdown
        raise asyncio.CancelledError()

    def joint_velocity_command(self, values, duration, duration_timeout=None, collision_check=False):
        """
        Sends velocity commads to the joints for the specified duration. 
        Returns a 1 on completion. 

        --------------
        values: A list or numpy array of joint velocity. 
        If it is a list or dictionary, it is assumed to be ordered 1-7.

        duration: The length of time the robot will execute the velocity command for.

        duration_timeout: if None, the function will return after duration. Else,
        the function will return after duration timeout even though the arm
        will move for time=duration. Currently this functionionallity uses
        python threading so use with caution. 

        collision_check: if True, will calculate the arms furture position and return -1 if
        it is in collision.

        TODO: -add dictionary functionality
              -add collision check
        """

        def velocity_command(values, duration):
            joint_vel_publisher = rospy.Publisher(
                f"/{self.robot_name}/in/joint_velocity", Base_JointSpeeds, queue_size=10, latch=True)
            joint_speeds = Base_JointSpeeds()
            joint_speeds.duration = 0
            for i in range(len(values)):
                speed = JointSpeed()
                speed.joint_identifier = i
                speed.value = values[i]
                joint_speeds.joint_speeds.append(speed)

            joint_vel_publisher.publish(joint_speeds)
            rospy.sleep(duration)
            self.stop()
            return 1

        if duration_timeout is not None:
            move_thread = threading.Thread(
                target=velocity_command, args=(values, duration))
            move_thread.start()
            rospy.sleep(duration_timeout)
            return 1
        else:
            return velocity_command(values, duration)

    def cartesian_velocity_command(self, values, duration, duration_timeout=None, collision_check=False, radians=False, block=True):
        """
        Sends a carteian velocity command for a specified duration. 
        Returns 1 on completion.

        ---------
        values: list or np array of the form: [x,y,z, x-twist, y-twist, z-twist, w-twist]

        duration: The length of time the robot will execute the velocity command for.

        duration_timeout: if None, the function will return after duration. Else,
        the function will return after duration timeout even though the arm
        will move for time=duration. Currently this functionionallity uses
        python threading so use with caution. 

        collision_check: if True, will calculate the arms furture position and return -1 if
        it is in collision.

        block: if True, follows duration_timeout; otherwise returns immediately

        TODO: add collision check
        """

        def velocity_command(values, duration):
            cartesian_vel_publisher = rospy.Publisher(
                f"/{self.robot_name}/in/cartesian_velocity", TwistCommand, queue_size=1, latch=True)
           
            empty_message = std_msgs.msg.Empty()
            cartesian_command = TwistCommand()

            # NOTE: There is a bug in the mapping of values/twists to angles
            # here that needs to be figured out
            if not radians:
                twists = euler_from_quaternion((values[3:]))
                cartesian_command.twist.linear_x = values[0]
                cartesian_command.twist.linear_y = values[1]
                cartesian_command.twist.linear_z = values[2]
                cartesian_command.twist.angular_x = twists[0]
                cartesian_command.twist.angular_y = twists[1]
                cartesian_command.twist.angular_z = twists[2]
            else:
                cartesian_command.twist.linear_x = values[0]
                cartesian_command.twist.linear_y = values[1]
                cartesian_command.twist.linear_z = values[2]
                cartesian_command.twist.angular_x = values[3]
                cartesian_command.twist.angular_y = values[4]
                cartesian_command.twist.angular_z = values[5]

            cartesian_command.reference_frame = 0
            # print(cartesian_command)
            cartesian_vel_publisher.publish(cartesian_command)
            if block:
                rospy.sleep(duration)
                #stop_publisher.publish(empty_message)
                # this sleep is necessary to process the sleep before the next potential command
                rospy.sleep(.00000001)
            return 1

        if duration_timeout is not None and block:
            move_thread = threading.Thread(
                target=velocity_command, args=(values, duration))
            move_thread.start()
            rospy.sleep(duration_timeout)
            return 1
        else:
            return velocity_command(values, duration)
    
    def goto_joint_pose_sim(self, joints):
        """              
        Sends the arm to the specified joint angles (in radians).
        This fucntion returns before completeley getting to 
        the pose

        Note: this function is primarily for the gazebo sim of the arm
        and may not work with the real arm. With the real arm 
        goto_joint_pose can be used.

        TODO: Figure out the difference/what is better between this
        and goto_joint_pose

        --------
        joints: list or np array of joint anlges (from 1 to 7) 
        """

        go_to_joints = rospy.ServiceProxy(
            f"/{self.robot_name}/base/play_joint_trajectory", PlayJointTrajectory)

        joint_angle_arr = ConstrainedJointAngles()

        for i in range(self.degrees_of_freedom):
            temp_joint = JointAngle(
                joint_identifier=i, value=np.rad2deg(joints[i]))
            joint_angle_arr.joint_angles.joint_angles.append(temp_joint)

        joint_msg = PlayJointTrajectoryRequest()
        joint_msg.input = joint_angle_arr
        go_to_joints(joint_msg)
        return
    
    def goto_joint_pose_relative_sim(self, joints):
        """              
        Sends the arm to the relative specified joint angles (in radians).
        This fucntion returns before completeley getting to 
        the pose

        Note: this function is primarily for the gazebo sim of the arm
        and may not work with the real arm. With the real arm 
        goto_joint_pose can be used.
        --------------
        joints: list or np array of joint anlges (from 1 to 7) 
        """
    
        go_to_joints = rospy.ServiceProxy(
            f"/{self.robot_name}/base/play_joint_trajectory", PlayJointTrajectory)
        
        current_joints = self.get_joint_angles()

        joint_angle_arr = ConstrainedJointAngles()

        for i in range(self.degrees_of_freedom):
            temp_joint = JointAngle(
                joint_identifier=i, value=np.rad2deg(current_joints[i] + joints[i]))
            joint_angle_arr.joint_angles.joint_angles.append(temp_joint)
        
        joint_msg = PlayJointTrajectoryRequest()
        joint_msg.input = joint_angle_arr
        go_to_joints(joint_msg)
        return


    def goto_cartesian_pose_sim(self, pose, speed=.1, duration=None, radians=True):
        """
        Sends the arm to the specified cartesian pose within a specified duration. 
        This function returns before completely getting to the pose.

        NOTE: there is a specific relationship between the duration and speed.
        If the duration is set to a number, it overrides the speed. So a 
        duration of 1 second will take 1 second regardless of the speed (if
        the position is reachable).
        NOTE: this function is primarily for the gazebo sim of the arm
        and does not with the real arm. With the real arm goto_cartesian_pose
        can be used.

        --------
        pose: list or np array of the form [x,y,z, x-rot, y-rot, z-rot], rotations in Euler
        radians: if True, the rotation values are in radians. Else, they are in degrees
        speed: the speed of the arm in m/s. The speed is for translation and orientation
        duration (int): the duration alloted for the arm to reach the goal pose. Default is None
        to prioritize speed over duration.

        TODO: add quaternion support
        TODO: maybe add speed for translation and orientation separately
        """

        go_to_cart = rospy.ServiceProxy(
            f"/{self.robot_name}/base/play_cartesian_trajectory", PlayCartesianTrajectory)
        cart_pose = ConstrainedPose()
        if radians:
            cart_pose.target_pose.x = pose[0]
            cart_pose.target_pose.y = pose[1]
            cart_pose.target_pose.z = pose[2]
            cart_pose.target_pose.theta_x = np.rad2deg(pose[3])
            cart_pose.target_pose.theta_y = np.rad2deg(pose[4])
            cart_pose.target_pose.theta_z = np.rad2deg(pose[5])
        else:
            cart_pose.target_pose.x = pose[0]
            cart_pose.target_pose.y = pose[1]
            cart_pose.target_pose.z = pose[2]
            cart_pose.target_pose.theta_x = pose[3]
            cart_pose.target_pose.theta_y = pose[4]
            cart_pose.target_pose.theta_z = pose[5]

        constraint = CartesianTrajectoryConstraint_type()
        if duration is not None:
            constraint.duration = [duration]
        constraint.speed = [CartesianSpeed(speed, speed)]

        cart_msg = PlayCartesianTrajectoryRequest()
        cart_msg.input.target_pose = cart_pose
        cart_pose.constraint.oneof_type = constraint

        # not sure if this constraint line changes anything
        cart_msg.input.constraint = constraint
        go_to_cart(cart_pose)
        return

    def goto_cartesian_relative_sim(self, pose, speed=.1, duration=None, radians=True):
        """
        Sends the arm via a displaced pose command relative to its current pose.

        NOTE: there is a specific relationship between the duration and speed.
        If the duration is set to a number, it overrides the speed. So a 
        duration of 1 second will take 1 second regardless of the speed (if
        the position is reachable).
        NOTE: this function is primarily for the gazebo sim of the arm
        though it can work with the real arm. With the goto_cartesian_pose
        can be used.
            try:
                rospy.init_node('arm_movement')
            except:
                pass

        --------
        pose: list or np array of the form [x,y,z, x-rot, y-rot, z-rot], rotations in Euler
        radians: if True, the rotation values are in radians. Else, they are in degrees
        speed: the speed of the arm in m/s. The speed is for translation and orientation
        duration (int): the duration alloted for the arm to reach the goal pose. Default is None
        to prioritize speed over duration.

        TODO: add quaternion support
        TODO: maybe add speed for translation and orientation separately
        """

        go_to_cart = rospy.ServiceProxy(
            f"/{self.robot_name}/base/play_cartesian_trajectory", PlayCartesianTrajectory)
        cart_pose = ConstrainedPose()

        curr_pose = self.get_eef_pose(quaternion=False)
        if radians:
            cart_pose.target_pose.x = curr_pose[0]+pose[0]
            cart_pose.target_pose.y = curr_pose[1]+pose[1]
            cart_pose.target_pose.z = curr_pose[2]+pose[2]
            cart_pose.target_pose.theta_x = np.rad2deg(curr_pose[3]+pose[3])
            cart_pose.target_pose.theta_y = np.rad2deg(curr_pose[4]+pose[4])
            cart_pose.target_pose.theta_z = np.rad2deg(curr_pose[5]+pose[5])
        else:
            cart_pose.target_pose.x = pose[0]
            cart_pose.target_pose.y = pose[1]
            cart_pose.target_pose.z = pose[2]
            cart_pose.target_pose.theta_x = np.rad2deg(curr_pose[3])+pose[3]
            cart_pose.target_pose.theta_y = np.rad2deg(curr_pose[4])+pose[4]
            cart_pose.target_pose.theta_z = np.rad2deg(curr_pose[5])+pose[5]

        constraint = CartesianTrajectoryConstraint_type()
        if duration is not None:
            constraint.duration = [duration]
        constraint.speed = [CartesianSpeed(speed, speed)]

        cart_msg = PlayCartesianTrajectoryRequest()
        cart_msg.input.target_pose = cart_pose
        cart_pose.constraint.oneof_type = constraint

        # not sure if this constraint line changes anything
        cart_msg.input.constraint = constraint
        go_to_cart(cart_pose)
        return
    
    def get_feedback_sub_args(self):
        return f'{self.robot_name}/base_feedback', BaseCyclic_Feedback
    
 -------------------------------------------------------------------
 #kortex_monitor_frame.py

import functools
import message_filters
import tkinter


from . import kortex_arm


class ListDisplay(tkinter.LabelFrame):
    def __init__(self, parent, label, labels=("x", "y", "z", "r", "p", "y")):
        super().__init__(parent, text=label)

        self._title = tkinter.Label(self, text=label)
        self._title.grid(row=0, column=0, columnspan=2)

        self._vars = []
        self._labels = []
        self._disp = []
        for i, val in enumerate(labels):
            var = tkinter.StringVar()
            self._vars.append(var)
            label = tkinter.Label(self, text=str(val))
            label.grid(row=i+1, column=0)
            self._labels.append(label)
            disp = tkinter.Label(self, textvariable=var)
            disp.grid(row=i+1, column=1, sticky="E")
            self._disp.append(disp)
            self.rowconfigure(i+1, weight=1)
        self.columnconfigure(0, weight=1)
        self.columnconfigure(1, weight=4)
    
    def update(self, vals):
        for val, var in zip(vals, self._vars):
            var.set(f"{val:.03f}")

class KortexStatusFrame(tkinter.LabelFrame):
    def __init__(self, parent, arm):
        super().__init__(parent, text="Status")

        self._sub = message_filters.Subscriber(*arm.get_feedback_sub_args())
        self._cache = message_filters.Cache(self._sub, cache_size=1, allow_headerless=True)

        self._tool_pose = ListDisplay(self, "Tool pose", ("x", "y", "z", "r", "p", "y"))
        self._tool_pose.grid(row=1, column=0)

        self._tool_twist = ListDisplay(self, "Tool twist", ("vx", "vy", "vz", "dr", "dp", "dy"))
        self._tool_twist.grid(row=1, column=1)

        self._update()

    def _update(self):
        self.update()
        self.after(1000, self._update)

    def update(self):
        # access is threadsafe though not guaranteed
        try:
            msg = self._cache.cache_msgs[-1]
        except IndexError:
            return
        self._tool_pose.update([
            msg.base.tool_pose_x, msg.base.tool_pose_y, msg.base.tool_pose_z,
            msg.base.tool_pose_theta_x, msg.base.tool_pose_theta_y, msg.base.tool_pose_theta_z
        ])
        self._tool_twist.update([
            msg.base.tool_twist_linear_x, msg.base.tool_twist_linear_y, msg.base.tool_twist_linear_z,
            msg.base.tool_twist_angular_x, msg.base.tool_twist_angular_y, msg.base.tool_twist_angular_z
        ])

class KortexMonitorFrame(tkinter.Frame):
    def __init__(self, parent, initial_config):
        super().__init__(parent)

        self._arm = kortex_arm.Arm()

        self._control_frame = tkinter.LabelFrame(self, text="Control")
        self._control_frame.grid(row=0, column=0)
        self.rowconfigure(0, weight=1)
        self.columnconfigure(0, weight=1)

        self._stop = tkinter.Button(self._control_frame, text="Stop", command=self._arm.stop)
        self._stop.grid(row=0, column=0)

        self._clear_faults = tkinter.Button(self._control_frame, text="Clear faults", 
                                            command=self._arm.clear_faults)
        self._clear_faults.grid(row=0, column=1)

        self._home_arm = tkinter.Button(self._control_frame, text="Home arm", 
                                        command=functools.partial(self._arm.home_arm, block=False))
        self._home_arm.grid(row=1, column=0)

        self._open_gripper = tkinter.Button(self._control_frame, text="Open gripper", 
                                            command=functools.partial(self._arm.open_gripper, block=False))
        self._open_gripper.grid(row=2, column=0)

        self._close_gripper = tkinter.Button(self._control_frame, text="Close gripper", 
                                             command=functools.partial(self._arm.close_gripper, block=False))
        self._close_gripper.grid(row=2, column=1)

        self._estop = tkinter.Button(self._control_frame, background="red", text="ESTOP", command=self._arm.estop)
        self._estop.grid(row=3, column=0, columnspan=2)

        self._status_frame = KortexStatusFrame(self, self._arm)
        self._status_frame.grid(row=0, column=1)
        self.columnconfigure(1, weight=1)

    def get_config(self):
        return dict()
    def set_state(self, state):
        pass

    

